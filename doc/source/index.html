<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>Plugins</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="index.css">
</head>
<body>
<header>
<h1 class="title">Plugins</h1>
</header>
<p>Guzzle ships with a number of plugins that deal with both the <code>Guzzle\Http</code> and <code>Guzzle\Service</code> namespace.</p>
<h1 id="http-plugins"><span class="header-section-number">1</span> HTTP Plugins</h1>
<p>Guzzle provides easy to use request plugins that add behavior to requests based on signal slot event notifications.</p>
<h2 id="over-the-wire-logging"><span class="header-section-number">1.1</span> Over the wire logging</h2>
<p>Use the <code>Guzzle\Http\Plugin\LogPlugin</code> to view all data sent over the wire, including entity bodies and redirects:</p>
<pre class="sourceCode php lineNumbers"><code>use Guzzle\Http\Client;
use Guzzle\Common\Log\ZendLogAdapter;
use Guzzle\Http\Plugin\LogPlugin;

$client = new Client(&#39;http://www.test.com/&#39;);

$adapter = new ZendLogAdapter(new \Zend_Log(new \Zend_Log_Writer_Stream(&#39;php://output&#39;)));
$logPlugin = new LogPlugin($adapter, LogPlugin::LOG_VERBOSE);

// Attach the plugin to the request, which will in turn be attached to all
// requests generated by the client
$client-&gt;addSubscriber($logPlugin);

$response = $client-&gt;get(&#39;http://google.com&#39;)-&gt;send();</code></pre>
<p>The code sample above wraps a <code>Zend_Log</code> object using a <code>Guzzle\Common\Log\ZendLogAdapter</code>. After attaching the request to the plugin, all data sent over the wire will be logged to stdout. The above code sample would output something like:</p>
<pre class="sourceCode none"><code>2011-03-10T20:07:56-06:00 DEBUG (7): www.google.com - &quot;GET / HTTP/1.1&quot; - 200 0 - 0.195698 0 45887
* About to connect() to google.com port 80 (#0)
*   Trying 74.125.227.50... * connected
* Connected to google.com (74.125.227.50) port 80 (#0)
&gt; GET / HTTP/1.1
Accept: */*
Accept-Encoding: deflate, gzip
User-Agent: Guzzle/0.9 (Language=PHP/5.3.5; curl=7.21.2; Host=x86_64-apple-darwin10.4.0)
Host: google.com

&lt; HTTP/1.1 301 Moved Permanently
&lt; Location: http://www.google.com/
&lt; Content-Type: text/html; charset=UTF-8
&lt; Date: Fri, 11 Mar 2011 02:06:32 GMT
&lt; Expires: Sun, 10 Apr 2011 02:06:32 GMT
&lt; Cache-Control: public, max-age=2592000
&lt; Server: gws
&lt; Content-Length: 219
&lt; X-XSS-Protection: 1; mode=block
&lt;
* Ignoring the response-body
* Connection #0 to host google.com left intact
* Issue another request to this URL: &#39;http://www.google.com/&#39;
* About to connect() to www.google.com port 80 (#1)
*   Trying 74.125.45.147... * connected
* Connected to www.google.com (74.125.45.147) port 80 (#1)
&gt; GET / HTTP/1.1
Host: www.google.com
Accept: */*
Accept-Encoding: deflate, gzip
User-Agent: Guzzle/0.9 (Language=PHP/5.3.5; curl=7.21.2; Host=x86_64-apple-darwin10.4.0)

&lt; HTTP/1.1 200 OK
&lt; Date: Fri, 11 Mar 2011 02:06:32 GMT
&lt; Expires: -1
&lt; Cache-Control: private, max-age=0
&lt; Content-Type: text/html; charset=ISO-8859-1
&lt; Set-Cookie: PREF=ID=8a61470bce22ed5b:FF=0:TM=1299809192:LM=1299809192:S=axQwBxLyhXV7mbE3; expires=Sun, 10-Mar-2013 02:06:32 GMT; path=/; domain=.google.com
&lt; Set-Cookie: NID=44=qxXLtXgSKI2S9_mG7KbN7yR2atSje1B9Eft_CHTyjTuIivwE9kB1sATn_YPmBNhZHiNyxcP4_tIYnawjSNWeAepixK3CoKHw-RINrgGNSG3RfpAG7M-IKxHmLhJM6NeA; expires=Sat, 10-Sep-2011 02:06:32 GMT; path=/; domain=.google.com; HttpOnly
&lt; Server: gws
&lt; X-XSS-Protection: 1; mode=block
&lt; Transfer-Encoding: chunked
&lt;
* Connection #1 to host www.google.com left intact
&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;
[...snipped]</code></pre>
<h2 id="truncated-exponential-backoff"><span class="header-section-number">1.2</span> Truncated exponential backoff</h2>
<p>The <code>Guzzle\Http\Plugin\ExponentialBackoffPlugin</code> automatically retries failed HTTP requests using truncated exponential backoff:</p>
<pre><code>use Guzzle\Http\Client;
use Guzzle\Http\Plugin\ExponentialBackoffPlugin;

$client = new Client(&#39;http://www.test.com/&#39;);

$backoffPlugin = new ExponentialBackoffPlugin();

// Add the exponential plugin to the client object
$client-&gt;addSubscriber($backoffPlugin);

$request = $client-&gt;get(&#39;http://google.com/&#39;);
$request-&gt;send();</code></pre>
<h2 id="php-based-caching-forward-proxy"><span class="header-section-number">1.3</span> PHP-based caching forward proxy</h2>
<p>Guzzle can leverage HTTP’s caching specifications using the <code>Guzzle\Http\Plugin\CachePlugin</code>. The CachePlugin provides a private transparent proxy cache that caches HTTP responses. The caching logic, based on <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html">RFC 2616</a>, uses HTTP headers to control caching behavior, cache lifetime, and supports ETag and Last-Modified based revalidation:</p>
<pre><code>use Guzzle\Http\Client;
use Doctrine\Common\Cache\ArrayCache;
use Guzzle\Common\Cache\DoctrineCacheAdapter;
use Guzzle\Http\Plugin\CachePlugin;

$client = new Client(&#39;http://www.test.com/&#39;);

$adapter = new DoctrineCacheAdapter(new ArrayCache());
$cachePlugin = new CachePlugin($adapter, true);

// Add the cache plugin to the client object
$client-&gt;addSubscriber($cachePlugin);

$request = $client-&gt;get(&#39;http://www.wikipedia.org/&#39;);
$request-&gt;send();

// The next request will revalidate against the origin server to see if it
// has been modified.  If a 304 response is recieved the response will be
// served from cache
$request-&gt;send();</code></pre>
<p>Guzzle doesn’t try to reinvent the wheel when it comes to caching or logging. Plenty of other frameworks have excellent solutions in place that you are probably already using in your applications. Guzzle uses adapters for caching and logging. Guzzle currently supports log adapters for the Zend Framework 1.0/2.0 and Monolog, and cache adapters for <a href="http://www.doctrine-project.org/">Doctrine 2.0</a> and the Zend Framework 1.0/2.0.</p>
<p>See :doc:`Caching &lt;/guide/http/caching&gt;` for more information on the caching plugin.</p>
<h2 id="cookie-session-plugin"><span class="header-section-number">1.4</span> Cookie session plugin</h2>
<p>Some web services require a Cookie in order to maintain a session. The <code>Guzzle\Http\Plugin\CookiePlugin</code> will add cookies to requests and parse cookies from responses using a CookieJar object:</p>
<pre><code>use Guzzle\Http\Client;
use Guzzle\Http\Plugin\CookiePlugin;
use Guzzle\Http\CookieJar\ArrayCookieJar;

$client = new Client(&#39;http://www.test.com/&#39;);

$cookiePlugin = new CookiePlugin(new ArrayCookieJar());

// Add the cookie plugin to the client object
$client-&gt;addSubscriber($cookiePlugin);

$request = $client-&gt;get(&#39;http://www.yahoo.com/&#39;);

// Send the request with no cookies and parse the returned cookies
$request-&gt;send();

// Send the request again, noticing that cookies are being sent
$request-&gt;send();

echo $request;</code></pre>
<h2 id="md5-hash-validator-plugin"><span class="header-section-number">1.5</span> MD5 hash validator plugin</h2>
<p>Entity bodies can sometimes be modified over the wire due to a faulty TCP transport or misbehaving proxy. If an HTTP response contains a Content-MD5 header, then a MD5 hash of the entity body of a response can be compared against the Content-MD5 header of the response to determine if the response was delivered intact. The <code>Guzzle\Http\Plugin\Md5ValidatorPlugin</code> will throw an <code>UnexpectedValueException</code> if the calculated MD5 hash does not match the Content-MD5 hash:</p>
<pre><code>use Guzzle\Http\Client;
use Guzzle\Http\Plugin\Md5ValidatorPlugin;

$client = new Client(&#39;http://www.test.com/&#39;);

$md5Plugin = new Md5ValidatorPlugin();

// Add the md5 plugin to the client object
$client-&gt;addSubscriber($md5Plugin);

$request = $client-&gt;get(&#39;http://www.yahoo.com/&#39;);
$request-&gt;send();</code></pre>
<p>Calculating the MD5 hash of a large entity body or an entity body that was transferred using a Content-Encoding is an expensive operation. When working in high performance applications, you might consider skipping the MD5 hash validation for entity bodies bigger than a certain size or Content-Encoded entity bodies (see <code>Guzzle\Http\Plugin\Md5ValidatorPlugin</code> for more information).</p>
<h2 id="history-plugin"><span class="header-section-number">1.6</span> History plugin</h2>
<p>The history plugin tracks all of the requests and responses sent through a request or client. This plugin can be useful for crawling or unit testing. By default, the history plugin stores up to 10 requests and responses.</p>
<pre class="sourceCode php"><code class="sourceCode php">use Guzzle\Http\Client;
use Guzzle\Http\Plugin\HistoryPlugin;

$client = new Client(&#39;http://www.test.com/&#39;);

$history = new HistoryPlugin();
$history-&gt;setLimit(5);

// Add the history plugin to the client object
$client-&gt;addSubscriber($history);

$client-&gt;get(&#39;http://www.yahoo.com/&#39;)-&gt;send();

echo $history-&gt;getLastRequest();
echo $history-&gt;getLastResponse();
echo count($history);</code></pre>
<h2 id="mock-plugin"><span class="header-section-number">1.7</span> Mock Plugin</h2>
<p>The mock plugin is useful for testing Guzzle clients. The mock plugin allows you to queue an array of responses that will satisfy requests sent from a client by consuming the request queue in FIFO order.</p>
<pre class="sourceCode php"><code class="sourceCode php">use Guzzle\Http\Client;
use Guzzle\Http\Plugin\MockPlugin;
use Guzzle\Http\Message\Response;

$client = new Client(&#39;http://www.test.com/&#39;);

$mock = new MockPlugin();
$mock-&gt;addResponse(new Response(200))
     -&gt;addResponse(new Response(404));

// Add the mock plugin to the client object
$client-&gt;addSubscriber($mock);

// The following request will receive a 200 response from the plugin
$client-&gt;get(&#39;http://www.example.com/&#39;)-&gt;send();

// The following request will receive a 404 response from the plugin
$client-&gt;get(&#39;http://www.test.com/&#39;)-&gt;send();</code></pre>
<h2 id="curl-auth-plugin"><span class="header-section-number">1.8</span> Curl Auth Plugin</h2>
<p>If your web service client requires basic authorization, then you can use the CurlAuthPlugin to easily add an Authorization header to each request sent by the client.</p>
<pre class="sourceCode php"><code class="sourceCode php">use Guzzle\Http\Client;
use Guzzle\Http\Plugin\CurlAuthPlugin;

$client = new Client(&#39;http://www.test.com/&#39;);

$authPlugin = new CurlAuthPlugin(&#39;username&#39;, &#39;password&#39;);

// Add the auth plugin to the client object
$client-&gt;addSubscriber($authPlugin);

$response = $client-&gt;get(&#39;projects/1/people&#39;)-&gt;send();
$xml = new SimpleXMLElement($response-&gt;getBody(true));
foreach ($xml-&gt;person as $person) {
    echo $person-&gt;email . &quot;\n&quot;;
}</code></pre>
<h2 id="batch-queue-plugin"><span class="header-section-number">1.9</span> Batch Queue Plugin</h2>
<p>Send a large number of requests using the batch queue plugin. Any request created by a client will automatically be tracked and queued by the BatchQueuePlugin. In the constructor of the plugin, you can specify the maximum amount of requests to keep in queue before implicitly flushing, or set 0 to never automatically flush.</p>
<pre class="sourceCode php"><code class="sourceCode php">use Guzzle\Http\Client;
use Guzzle\Http\Plugin\BatchQueuePlugin;

$client = new Client(&#39;http://www.test.com/&#39;);

// Here we are saying that if 10 or more requests are in the batch queue,
// then it must automatically flush the queue and send the requests.
$batchPlugin = new BatchQueuePlugin(10);

// Add the batch plugin to the client object
$client-&gt;addSubscriber($batchPlugin);

// Queue up some requests on the BatchQueuePlugin
$request1 = $client-&gt;get(&#39;/&#39;);
$request2 = $client-&gt;get(&#39;/&#39;);
$request3 = $client-&gt;get(&#39;/&#39;);

// If the batch plugin is handy, you can call the flush method directly
$batchPlugin-&gt;flush();

// If you no longer have the batch plugin handy, you can emit the &#39;flush&#39; event
// from the client
$client-&gt;dispatch(&#39;flush&#39;);</code></pre>
<h2 id="oauth-1.0-plugin"><span class="header-section-number">1.10</span> OAuth 1.0 Plugin</h2>
<p>Guzzle ships with an OAuth 1.0 plugin that can sign requests using a consumer key, consumer secret, OAuth token, and OAuth secret. Here’s an example showing how to send an authenticated request to the Twitter REST API:</p>
<pre class="sourceCode php"><code class="sourceCode php">use Guzzle\Http\Client;
use Guzzle\Http\Plugin\OauthPlugin;

$client = new Client(&#39;http://api.twitter.com/1&#39;);
$oauth = new OauthPlugin(array(
    &#39;consumer_key&#39;    =&gt; &#39;my_key&#39;,
    &#39;consumer_secret&#39; =&gt; &#39;my_secret&#39;,
    &#39;token&#39;           =&gt; &#39;my_token&#39;,
    &#39;token_secret&#39;    =&gt; &#39;my_token_secret&#39;
));
$client-&gt;addSubscriber($oauth);

$response = $client-&gt;get(&#39;statuses/public_timeline.json&#39;)-&gt;send();</code></pre>
<p>If you need to use a custom signing method, you can pass a <code>signature_method</code> configuration option in the constructor of the OAuth plugin. The <code>signature_method</code> option must be a callable variable that accepts a string to sign and signing key and returns a signed string.</p>
<h2 id="async-plugin"><span class="header-section-number">1.11</span> Async Plugin</h2>
<p>The AsyncPlugin allows you to send requests that do not wait on a response. This is handled through cURL by utilizing the progress event. When a request has sent all of its data to the remote server, Guzzle adds a 1ms timeout on the request and instructs cURL to not download the body of the response. The async plugin then catches the exception and adds a mock response to the request, along with an X-Guzzle-Async header to let you know that the response was not fully downloaded.</p>
<pre class="sourceCode php"><code class="sourceCode php">use Guzzle\Http\Client;
use Guzzle\Http\Plugin\AsyncPlugin;

$client = new Client(&#39;http://www.example.com&#39;);
$client-&gt;addSubscriber(new AsyncPlugin());
$response = $client-&gt;get()-&gt;send();</code></pre>
<h1 id="service-plugins"><span class="header-section-number">2</span> Service Plugins</h1>
<h2 id="plugin-collection-plugin"><span class="header-section-number">2.1</span> Plugin Collection Plugin</h2>
<p>This plugin can be used to attached plugins to every client created by a <code>Guzzle\Service\Builder\ServiceBuilder</code>. The following example demonstrates adding a HistoryPlugin to each client created by a service builder.</p>
<pre class="sourceCode php"><code class="sourceCode php">use Guzzle\Service\Builder\ServiceBuilder;
use Guzzle\Service\Plugin\PluginCollectionPlugin;

$builder = ServiceBuilder::factory(&#39;config.json&#39;);
$builder-&gt;addSubsriber(new PluginCollectionPlugin(array(new HistoryPlugin())));</code></pre>
<h2 id="third-party-plugins"><span class="header-section-number">2.2</span> Third-party plugins</h2>
<ul>
<li><a href="https://github.com/davedevelopment/guzzle-wsse-auth-plugin">WSSE Authentication plugin</a></li>
</ul>
</body>
</html>
